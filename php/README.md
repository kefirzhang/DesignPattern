# DesignPattern
DesignPattern
设计模式
Abstract Factory (抽象工厂）通过指定对象组的种类而非单个对象的类型来支持创建一组相关的对象
Adapter （适配器） 把一个类的接口转变成为另一个接口
Bridge（桥接）把接口和实现分离开来，使他们能够独立的变化
Composite（组合）创建一个包含其他同类对象的对象，使得客户代码可以与最上层对象交互而无需考虑所有的细节对象
Decrorator（装饰器）给一个对象动态的添加职责，而无需为了每一个可能的职责配置情况去创建特定的子类（派生类）
Facade（外观）为没有提供一致接口的代码提供一个一致的接口
Factory Method（）做特定基类的派生类的实例化时候，除了在Factory Method内部之外均无需了解各个派生对象的具体类型
Iterator（迭代器）提供一个服务对象来顺序的访问一组元素中的各个元素
Observer（观察者）使一组相关的对象相互同步，方法是让另一个对象负责：在这组对象中的任何一个发生改变时，由它把这种变化通知给组里的所有对象
Singleton（单件）为有且仅有一个实例的类提供一种全局访问功能
Strategy（策略）定义一组算法或者行为，使得他们可以动态的互相替换
Template Method（模版方法）定义一个操作的算法结构，但是把部分实现的细节留给子类（派生类）
.......
OO基础
抽象
封装
继承
多态
OO原则
封装变化-找出应用中可能需要变化之处，把他们独立出来，不要把他们和不需要变化的代码混在一起。
多用组合，少用继承
针对接口编程，不针对实现编程
为交互对象之间的松耦合设计而努力
类应该对扩展开放，对修改关闭
依赖抽象，不要依赖具体类
最少知识原则，只和你的密友交谈。只和朋友交谈，
别找我，我会找你，别调用我们，我们会调用你，底层组件不能调用高层组件。高层组件可以调用底层组件。
类应该只有一个改变的理由，一个类应该只有一个引起变化的原因。

设计模式
什么是模式，模式是在某种情景下，针对某问题的某种解决方案
情景是应用某个模式的情况，应该是不断出现的情况。
问题就是在某个情景下你想要达到的目标，但也可以是某情景下的约束。
解决方案就是你所追求的，一个通用的设计，用来解决，约束，达到目标
如果你发现你自己处于某个情景下，面对着所欲达到的目标被一群约束影响的问题，然而你能够应用某个设计，克服这些约束并达到该目标，将你领向某个解决方案。

策略模式-定义算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
观察者模式-让你的对象知悉现况
装饰者模式-装饰对象
工厂模式-烘烤OO的精华
单件模式-独一无二的对象
命令模式-封装调用
适配器和外观模式-随遇而安
模版方法模式-封装方法
迭代器和组合模式-管理良好的集合
状态模式-事物的状态
代理模式-控制对象访问
复合模式-模式中的模式
