# DesignPattern
DesignPattern
设计模式
Abstract Factory (抽象工厂）通过指定对象组的种类而非单个对象的类型来支持创建一组相关的对象
Adapter （适配器） 把一个类的接口转变成为另一个接口
Bridge（桥接）把接口和实现分离开来，使他们能够独立的变化
Composite（组合）创建一个包含其他同类对象的对象，使得客户代码可以与最上层对象交互而无需考虑所有的细节对象
Decrorator（装饰器）给一个对象动态的添加职责，而无需为了每一个可能的职责配置情况去创建特定的子类（派生类）
Facade（外观）为没有提供一致接口的代码提供一个一致的接口
Factory Method（）做特定基类的派生类的实例化时候，除了在Factory Method内部之外均无需了解各个派生对象的具体类型
Iterator（迭代器）提供一个服务对象来顺序的访问一组元素中的各个元素
Observer（观察者）使一组相关的对象相互同步，方法是让另一个对象负责：在这组对象中的任何一个发生改变时，由它把这种变化通知给组里的所有对象
Singleton（单件）为有且仅有一个实例的类提供一种全局访问功能
Strategy（策略）定义一组算法或者行为，使得他们可以动态的互相替换
Template Method（模版方法）定义一个操作的算法结构，但是把部分实现的细节留给子类（派生类）
.......
OO基础
抽象 面对信息可以忽略其中某些方面，关注通用的共性
封装 也叫做信息封装，确保组件不会以不可预期的方式改变其它组件的内部状态；
只有在那些提供了内部状态改变方法的组件中，才可以访问其内部状态。每类组件都提供了一个与其它组件联系的接口，并规定了其它组件进行调用的方法
继承，子类就会继承父类所有公有的和受保护的方法，除非子类覆盖了父类的方法，被继承的方法都会保留其原有功能
多态 实例会牵涉到不同的组件（状态，变量，信息），实例引用的结果将根据不同的组件而变得不同



简单的说，类就是一种用户定义的数据类型，跟结构类似；并且，类具有自己的成员变量和成员函数（方法），通过它们可以对类自身进行操作。
指能够把一个实体的信息、功能、响应都装入一个单独的对象中的特性。封装的优点如下：
对象就是类的实例。类与对象的关系就如类型和变量的关系，所有对类的操作都必须通过对象来实现。当一个类定义了多个对象时，每个对象拥有各自的成员数据。

OO原则
封装变化-找出应用中可能需要变化之处，把他们独立出来，不要把他们和不需要变化的代码混在一起。
多用组合，少用继承
针对接口编程，不针对实现编程
为交互对象之间的松耦合设计而努力
类应该对扩展开放，对修改关闭
依赖抽象，不要依赖具体类
最少知识原则，只和你的密友交谈。只和朋友交谈，
别找我，我会找你，别调用我们，我们会调用你，底层组件不能调用高层组件。高层组件可以调用底层组件。
类应该只有一个改变的理由，一个类应该只有一个引起变化的原因。

设计模式
什么是模式，模式是在某种情景下，针对某问题的某种解决方案
情景是应用某个模式的情况，应该是不断出现的情况。
问题就是在某个情景下你想要达到的目标，但也可以是某情景下的约束。
解决方案就是你所追求的，一个通用的设计，用来解决，约束，达到目标
如果你发现你自己处于某个情景下，面对着所欲达到的目标被一群约束影响的问题，然而你能够应用某个设计，克服这些约束并达到该目标，将你领向某个解决方案。

策略模式-定义算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
观察者模式-让你的对象知悉现况
装饰者模式-装饰对象
工厂模式-烘烤OO的精华
单件模式-独一无二的对象
命令模式-封装调用
适配器和外观模式-随遇而安
模版方法模式-封装方法
迭代器和组合模式-管理良好的集合
状态模式-事物的状态
代理模式-控制对象访问
复合模式-模式中的模式
